#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov 18 23:04:43 2016

@author: luxihan
"""

import scipy as sp
import os
import scipy.optimize as opt
import scipy.interpolate as spinter
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator
import pandas as pd
import math
import pa6_ss as p6_ss

def get_fert(totpers, graph):
    per_input = np.array([-1, 0, 2, 4, 6, 8, 10, 12, 16, 18.5, 22, 27, 32, 37, 42, 47, 50, 55, 60, 70, 80 , 90, 99, 100])
    per_input += 1
    fert_input = np.array([0, 0, 0, 0, 0, 0, 0, 0.3, 12.3, 47.1, 80.7, 105.5, 98.0, 49.3, 10.4, 0.8, 0, 0, 0, 0, 0, 0 , 0, 0])
    fert_input /= 1000
    fert_func = spinter.interp1d(per_input, fert_input, kind='cubic')
    step = 100 / totpers
    per_output = [(i + 1) * step for i in range(totpers)]
    fert_output = [fert_func(age) for age in per_output]
#    fert_output = []
#    start_year = 0
#    end_year = 0
#    for y in per_output:
#        start_year = end_year
#        end_year = y
#        start_index = int(start_year // 1)
#        end_index = int(end_year // 1)
#        fert_rate = 0
#        for i in range(start_index, end_index + 1):
#            if i == start_index:
#                fert_rate += fert_func(start_index + 1) * (start_index + 1 - start_year)
#            elif i == end_index and end_year > end_index:
#                fert_rate += fert_func(end_index + 1) * (end_year - end_index)
#            elif start_index < i < end_index:
#                fert_rate += fert_func(i + 1)
#        fert_rate /= step
#        fert_output.append(fert_rate)
    fert_output = np.array(fert_output) / 2
    fert_output[fert_output < 0] = 0
    print(fert_output.max())
    if graph:
        cur_path = os.path.split(os.path.abspath(__file__))[0]
        output_fldr = "images"
        output_dir = os.path.join(cur_path, output_fldr)
        if not os.access(output_dir, os.F_OK):
            os.makedirs(output_dir)

        # Plot steady-state consumption and savings distributions
#        fig, ax = plt.subplots()
        if totpers == 100:
            plt.plot(per_output, fert_output, marker = "o",label= "{} period".format(totpers))
        else:
            plt.scatter(per_output, fert_output, marker = "o", c= "red", label= "{} period".format(totpers))
        # for the minor ticks, use no labels; default NullFormatter
#        minorLocator = MultipleLocator(1)
#        ax.xaxis.set_minor_locator(minorLocator)
        plt.grid(b=True, which='major', color='0.65', linestyle='-')
        plt.title('Fertility Rate', fontsize=20)
        plt.xlabel(r'Year $s$')
        plt.ylabel(r'Rate')
        plt.xlim((0, 101))
        plt.ylim((-0.001, 0.065))
        plt.legend(loc='upper right')
    return np.array(fert_output)
    
cur_path = os.path.split(os.path.abspath(__file__))[0]
output_fldr = "images"
output_dir = os.path.join(cur_path, output_fldr)
if not os.access(output_dir, os.F_OK):
    os.makedirs(output_dir)
get_fert(100, True)
output_path = os.path.join(output_dir, "fert_rate1")
plt.savefig(output_path)
plt.show()
get_fert(100, True)
get_fert(80, True)
output_path = os.path.join(output_dir, "fert_rate2")
plt.savefig(output_path)
plt.show()
get_fert(100, True)
get_fert(20, True)
output_path = os.path.join(output_dir, "fert_rate3")
plt.savefig(output_path)
plt.show()


def get_mort(totpers, graph):
    df = pd.read_csv("mort_rates2011.csv", thousands = ",")
    inf_mortrate = 5.90 /1000
    df_per = df.iloc[ : 100, :]
    df_per["mort_rate"] = (df_per.loc[:, "Male Mort. Rate"] * df_per.loc[:, "Num. Male Lives"] +\
                        df_per.loc[:, "Female Mort. Rate"] * df_per.loc[:, "Num. Female Lives"])\
                        / (df_per.loc[:, "Num. Male Lives"] + df_per.loc[:, "Num. Female Lives"])
    df_per.loc[99, "mort_rate"] = 1.0
    year = df["Age"] + 1
    mort_input = df_per["mort_rate"].tolist()
    step = 100/ totpers
    year_output = [(i + 1) * step for i in range(totpers)]
    mort_rate = []
    start_year = 0
    end_year = 0
    for year in year_output:
        start_year = end_year
        end_year = year
        start_index = int(start_year // 1)
        end_index = int(end_year // 1)
        sur_rate = 1
        for i in range(start_index, end_index + 1):
            if i == start_index:
                sur_rate *= (1 - mort_input[start_index] * (start_index + 1 - start_year))
            elif i == end_index and end_year > end_index:
                sur_rate *= (1 - mort_input[end_index] * (end_year - end_index))
            elif start_index < i < end_index:
                sur_rate *= (1 - mort_input[i])
        mort_rate.append(1 - sur_rate)
    if graph:
        cur_path = os.path.split(os.path.abspath(__file__))[0]
        output_fldr = "images"
        output_dir = os.path.join(cur_path, output_fldr)
        if not os.access(output_dir, os.F_OK):
            os.makedirs(output_dir)

        # Plot steady-state consumption and savings distributions
#        fig, ax = plt.subplots()
        if totpers == 100:
            plt.plot(year_output, mort_rate, marker = "o",label= "{} period".format(totpers))
        else:
            plt.scatter(year_output, mort_rate, marker = "o", c = "red", label= "{} period".format(totpers))
        # for the minor ticks, use no labels; default NullFormatter
#        minorLocator = MultipleLocator(1)
#        ax.xaxis.set_minor_locator(minorLocator)
        plt.grid(b=True, which='major', color='0.65', linestyle='-')
        plt.title('Mortality Rate', fontsize=20)
        plt.xlabel(r'Year $s$')
        plt.ylabel(r'Rate')
        plt.xlim((0, 101))
        plt.ylim((0, 1.01))
        plt.legend(loc='upper left')
    return np.array(mort_rate), inf_mortrate
    
#a, b= get_mort(100, True)
cur_path = os.path.split(os.path.abspath(__file__))[0]
output_fldr = "images"
output_dir = os.path.join(cur_path, output_fldr)
if not os.access(output_dir, os.F_OK):
    os.makedirs(output_dir)
get_mort(100, True)
output_path = os.path.join(output_dir, "mort_rate1")
plt.savefig(output_path)
plt.show()
get_mort(100, True)
get_mort(80, True)
output_path = os.path.join(output_dir, "mort_rate2")
plt.savefig(output_path)
plt.show()
get_mort(100, True)
get_mort(20, True)
output_path = os.path.join(output_dir, "mort_rate3")
plt.savefig(output_path)
plt.show()


def get_imm_resid(totpers, graph):
    df_pop = pd.read_csv("pop_data.csv", thousands = ",")
    df_pop = df_pop.iloc[ : -1, :]
#    year_input = df_pop.Age + 1
    pop_2012 = df_pop["2012"]
    pop_2013 = df_pop["2013"]
    step = 100 / totpers
    year = [(i + 1) * step for i in range(totpers)]
    start_year = 0
    end_year = 0
    pop_t = []
    pop_tplus1 = []
    for y in year:
        start_year = end_year
        end_year = y
        start_index = int(start_year // 1)
        end_index = int(end_year // 1)
        pop_1 = 0
        pop_2 = 0
        for i in range(start_index, end_index + 1):
            if i == start_index:
                pop_1 += pop_2012[start_index] * (start_index + 1 - start_year)
                pop_2 += pop_2013[start_index] * (start_index + 1 - start_year)
            elif i == end_index and end_year > end_index:
                pop_1 += pop_2012[end_index] * (end_year - end_index)
                pop_2 += pop_2013[end_index] * (end_year - end_index)
            elif start_index < i < end_index:
                pop_1 += pop_2012[i]
                pop_2 += pop_2013[i]
        pop_t.append(pop_1)
        pop_tplus1.append(pop_2)
    pop_t = np.array(pop_t)
#    plt.plot(year, pop_t, marker = "D")
#    year_input = [(i + 1) for i in range(100)]
#    plt.show()
#    print(pop_t)
    pop_tplus1 = np.array(pop_tplus1)
#    pop_func_t = spinter.interp1d(year_input, pop_2012, kind='cubic')
#    pop_func_tplus1 = spinter.interp1d(year_input, pop_2013, kind='cubic')
#    pop_t = np.array([pop_func_t(j) for j in year])
#    pop_tplus1 = np.array([pop_func_tplus1(j) for j in year])
    mort_rate, inf_mortrate = get_mort(totpers, False)
#    print(len(mort_rate))
    fert_rate = get_fert(totpers, False)
#    print(fert_rate)
    immi_rate = []
    for y in range(totpers):
        if y == 0:
            t_fert = (pop_t * fert_rate).sum()
#            print(len(fert_rate[fert_rate <= 0]))
#            print(pop_t * fert_rate)
#            print(t_fert, pop_tplus1[y], pop_2012[y], fert_rate.max())
            immi_rate_t = (pop_tplus1[y] - (1 - inf_mortrate) * t_fert) / pop_t[y]
            immi_rate.append(immi_rate_t)
        else:
            immi_rate_t = (pop_tplus1[y] - (1 - mort_rate[y - 1]) * pop_t[y - 1]) / pop_t[y]
            immi_rate.append(immi_rate_t)
    if graph:
        plt.plot(year, immi_rate, marker = "D")
        output_fldr = "images"
        output_dir = os.path.join(cur_path, output_fldr)
        if not os.access(output_dir, os.F_OK):
            os.makedirs(output_dir)

        # Plot steady-state consumption and savings distributions
#        fig, ax = plt.subplots()
        plt.plot(year, immi_rate, marker = "o",label= "{} period".format(totpers))
        # for the minor ticks, use no labels; default NullFormatter
#        minorLocator = MultipleLocator(1)
#        ax.xaxis.set_minor_locator(minorLocator)
        plt.grid(b=True, which='major', color='0.65', linestyle='-')
        plt.title('Immigration Rate', fontsize=20)
        plt.xlabel(r'Year $s$')
        plt.ylabel(r'Rate')
        plt.xlim((0, 101))
#        plt.ylim((0, 0.03))
        plt.legend(loc='upper left')
        output_path = os.path.join(output_dir, "immi_rate{}".format(totpers))
        plt.savefig(output_path)
        plt.show()
    return np.array(immi_rate)
    
get_imm_resid(100, True)
get_imm_resid(80, True)
get_imm_resid(20, True)

def pop_next(pop_t, fert_rate, mort_rate, inf_mortrate, immi_rate):
    pop_tplus1 = np.zeros(len(pop_t))
    pop_tplus1[1 :] = (1 - mort_rate[: -1]) * pop_t[: -1] + immi_rate[1 :] * pop_t[1 :]
    pop_tplus1[0] = (1- inf_mortrate) * np.dot(fert_rate, pop_t) + immi_rate[0] * pop_t[0]
    pop_tplus1_norm =pop_tplus1 / pop_tplus1.sum()
    g_rate = (pop_tplus1.sum() / pop_tplus1_norm.sum()) - 1
    return (pop_tplus1_norm, g_rate)
    
    
def get_pop_ss(graph):
    mort_rate, inf_mortrate = get_mort(100, False)
    immi = get_imm_resid(100, False)
    fert_rate = get_fert(100, False)
    omega = np.zeros([100, 100])
    for i in range(100):
        if i == 0:
            omega[0, :] = (1- inf_mortrate) * fert_rate
            omega[0, 0] += immi[0]
        else:
            omega[i, i - 1] = 1 - mort_rate[i - 1]
            omega[i, i] = immi[i]
    eig = np.linalg.eig(omega)
    eig_val = np.real(eig[0]).max()
    eig_vec = eig[1][:, 0]
    eig_vec /= eig_vec.sum()
    year = np.linspace(1, 100, 100)
    if graph:
        output_fldr = "images"
        output_dir = os.path.join(cur_path, output_fldr)
        if not os.access(output_dir, os.F_OK):
            os.makedirs(output_dir)

        # Plot steady-state consumption and savings distributions
#        fig, ax = plt.subplots()
        plt.plot(year, eig_vec, label= "Stationary Population Distribution")
        # for the minor ticks, use no labels; default NullFormatter
#        minorLocator = MultipleLocator(1)
#        ax.xaxis.set_minor_locator(minorLocator)
        plt.grid(b=True, which='major', color='0.65', linestyle='-')
        plt.title('Stationary Population Dist', fontsize=20)
        plt.xlabel(r'Year $s$')
        plt.ylabel(r'Population')
        plt.xlim((0, 101))
#        plt.ylim((0, 0.03))
        plt.legend(loc='lower left')
        output_path = os.path.join(output_dir, "pop_ss")
        plt.savefig(output_path)
        plt.show()
    return (omega, eig_val - 1, eig_vec)
    
    
def pop_timepath(T, graph):
    mort_rate, inf_mortrate = get_mort(100, False)
    immi_rate = get_imm_resid(100, False)
    fert_rate = get_fert(100, False)
    df_pop = pd.read_csv("pop_data.csv", thousands = ",")
    df_pop = df_pop.iloc[ : -1, :]
    pop_2013 = np.array(df_pop["2013"])
    pop_init = pop_2013 / pop_2013.sum()
    omega, g_rate_ss, pop_ss = get_pop_ss(False)
    pop_tpath = np.zeros([100, T + 100])
    g_rate_path = np.zeros(T + 100 -1)
    for i in range(T - 1):
        if i == 0:
            pop_tpath[:, i] = pop_init
        else:
            pop_t = pop_tpath[:, i - 1]
            pop_tplus1, g_rate = pop_next(pop_t, fert_rate, mort_rate, inf_mortrate, immi_rate)
            g_rate_path[i - 1] += g_rate
            pop_tpath[:, i] += pop_tplus1
    for i in range(100):
        pop_tpath[:, T - 1 + i] = pop_ss
    g_rate_path[T  - 2:] = g_rate_ss
    year = np.linspace(1, 100, 100)
    time = np.linspace(2, T + 100, T + 100 - 1)
    if graph:
        output_fldr = "images"
        output_dir = os.path.join(cur_path, output_fldr)
        if not os.access(output_dir, os.F_OK):
            os.makedirs(output_dir)

        # Plot steady-state consumption and savings distributions
#        fig, ax = plt.subplots()
        plt.plot(year, pop_tpath[:, 0], label= "period{}".format(1))
        plt.plot(year, pop_tpath[:, 9], label= "period{}".format(10))
        plt.plot(year, pop_tpath[:, 39], label= "period{}".format(40))
        plt.plot(year, pop_tpath[:, 199], label= "period{}".format(200))
        plt.grid(b=True, which='major', color='0.65', linestyle='-')
        plt.title('Population Distribution', fontsize=20)
        plt.xlabel(r'Year $s$')
        plt.ylabel(r'Population')
        plt.xlim((0, 101))
#        plt.ylim((0, 0.03))
        plt.legend(loc='lower left')
        output_path = os.path.join(output_dir, "pop_dist")
        plt.savefig(output_path)
        plt.show()
        
        output_fldr = "images"
        output_dir = os.path.join(cur_path, output_fldr)
        if not os.access(output_dir, os.F_OK):
            os.makedirs(output_dir)

        # Plot steady-state consumption and savings distributions
#        fig, ax = plt.subplots()
        plt.plot(time, g_rate_path, label = "Growth Rate")
        plt.plot(time, np.array([g_rate_ss] * len(time)), '--')
        plt.grid(b=True, which='major', color='0.65', linestyle='-')
        plt.title('Population Growth Rate Path', fontsize=20)
        plt.xlabel(r'Year $s$')
        plt.ylabel(r'Growth Rate')
        plt.xlim((0, T + 50))
        plt.ylim((0, 0.008))
        plt.legend(loc='upper right')
        output_path = os.path.join(output_dir, "pop_growth")
        plt.savefig(output_path)
        plt.show()
    return pop_tpath, g_rate_path
    
get_pop_ss(True)
pop_timepath(200, True)
   
##########################################################################
S = 80
#S = [1 ,2 ,3]
nvec = []
for i in range(S):
    if (i <= round(S * 2 / 3)):
        nvec += [1,]
    else:
        nvec += [0.2,]
nvec = np.array(nvec)
A = 1
alpha = 0.35
delta = 0.05
beta = 0.96
#delta = 0.6415
#beta = 0.442
f_params = (S, nvec, A, alpha, delta, beta)
sigma = 2.2
g_y = 0.03
L = sum(nvec)
SS_tol =  math.e**(-12)
EulDiff = True
mort_rate, inf_mortrate = get_mort(100, False)
mort_rate = mort_rate[20 :]
immi_rate = get_imm_resid(100, False)
immi_rate = immi_rate[20 :]
fert_rate = get_fert(100, False)
fert_rate = fert_rate[20 :]
omeg_ss, g_rate, pop_ss = get_pop_ss(False)
pop_ss = pop_ss[20 :]
g_rate -= 1
params = (beta, sigma, nvec, A, alpha, delta, g_y, mort_rate, immi_rate, pop_ss, g_rate, SS_tol, EulDiff)
f_params = (nvec, A, alpha, delta, g_y, g_rate, pop_ss, immi_rate, pop_ss)
SS_graph = True
nonSS_graph = True

bvec_guess1 = np.ones(S - 1)

bvec_guess2 = \
    np.array([-0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2])

bvec_guess3 = \
    np.array([-0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    -0.01, 0.1, 0.2, 0.23, 0.25, 0.23, 0.2, 0.1,
    0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1,
    0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1,
    0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
#bvec_guess3 = [0.1, 0.1]
bvec_guess = bvec_guess3
f_3 = p6_ss.feasible(f_params, bvec_guess)

eul_args = (beta, sigma, nvec, A, alpha, delta, g_y, mort_rate, immi_rate, pop_ss, g_rate, EulDiff)

#b_ss = opt.fsolve(p6_ss.EulerSys, bvec_guess, args=(eul_args), xtol=SS_tol)

#ss_output = p6_ss.get_SS(params, bvec_guess, SS_graph)
#b_ss = ss_output['b_ss']
#K_ss = ss_output['K_ss']
#C_ss = ss_output['C_ss']


        
        
    
    